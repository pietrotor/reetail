/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Current-Payment
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  CreatePlaidTokenEndpointApiV1IntegrationsPlaidTokenPost200,
  HTTPValidationError,
  IntegrationCreate,
  IntegrationRead,
  IntegrationType,
  IntegrationUpdate
} from '../../model';

import { customFetch } from '../../../mutator/custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create Plaid Token Endpoint
 */
export const createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<CreatePlaidTokenEndpointApiV1IntegrationsPlaidTokenPost200>(
      {url: `/api/v1/integrations/plaid/token`, method: 'POST', signal
    },
      options);
    }
  


export const getCreatePlaidTokenEndpointApiV1IntegrationsPlaidTokenPostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost>>, TError,void, TContext> => {
    
const mutationKey = ['createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost>>, void> = () => {
          

          return  createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePlaidTokenEndpointApiV1IntegrationsPlaidTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost>>>
    
    export type CreatePlaidTokenEndpointApiV1IntegrationsPlaidTokenPostMutationError = unknown

    /**
 * @summary Create Plaid Token Endpoint
 */
export const useCreatePlaidTokenEndpointApiV1IntegrationsPlaidTokenPost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof createPlaidTokenEndpointApiV1IntegrationsPlaidTokenPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreatePlaidTokenEndpointApiV1IntegrationsPlaidTokenPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Plaid Accounts Endpoint
 */
export const getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/v1/integrations/plaid/accounts`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetQueryKey = () => {
    return [`/api/v1/integrations/plaid/accounts`] as const;
    }

    
export const getGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetQueryOptions = <TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>> = ({ signal }) => getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>>
export type GetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetQueryError = unknown


export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>,
          TError,
          Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>,
          TError,
          Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Plaid Accounts Endpoint
 */

export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>> = ({ signal }) => getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>>
export type GetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspenseQueryError = unknown


export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspense<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspense<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspense<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Plaid Accounts Endpoint
 */

export function useGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspense<TData = Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPlaidAccountsEndpointApiV1IntegrationsPlaidAccountsGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Credit Card Accounts Endpoint
 */
export const getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/v1/integrations/credit_card/accounts`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetQueryKey = () => {
    return [`/api/v1/integrations/credit_card/accounts`] as const;
    }

    
export const getGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetQueryOptions = <TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>> = ({ signal }) => getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>>
export type GetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetQueryError = unknown


export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>,
          TError,
          Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>,
          TError,
          Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Credit Card Accounts Endpoint
 */

export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>> = ({ signal }) => getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>>
export type GetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspenseQueryError = unknown


export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspense<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspense<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspense<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Credit Card Accounts Endpoint
 */

export function useGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspense<TData = Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCreditCardAccountsEndpointApiV1IntegrationsCreditCardAccountsGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create Integration Endpoint
 */
export const createIntegrationEndpointApiV1IntegrationsIntegrationTypePost = (
    integrationType: IntegrationType,
    integrationCreate: IntegrationCreate,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<IntegrationRead>(
      {url: `/api/v1/integrations/${encodeURIComponent(String(integrationType))}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: integrationCreate, signal
    },
      options);
    }
  


export const getCreateIntegrationEndpointApiV1IntegrationsIntegrationTypePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIntegrationEndpointApiV1IntegrationsIntegrationTypePost>>, TError,{integrationType: IntegrationType;data: IntegrationCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createIntegrationEndpointApiV1IntegrationsIntegrationTypePost>>, TError,{integrationType: IntegrationType;data: IntegrationCreate}, TContext> => {
    
const mutationKey = ['createIntegrationEndpointApiV1IntegrationsIntegrationTypePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createIntegrationEndpointApiV1IntegrationsIntegrationTypePost>>, {integrationType: IntegrationType;data: IntegrationCreate}> = (props) => {
          const {integrationType,data} = props ?? {};

          return  createIntegrationEndpointApiV1IntegrationsIntegrationTypePost(integrationType,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateIntegrationEndpointApiV1IntegrationsIntegrationTypePostMutationResult = NonNullable<Awaited<ReturnType<typeof createIntegrationEndpointApiV1IntegrationsIntegrationTypePost>>>
    export type CreateIntegrationEndpointApiV1IntegrationsIntegrationTypePostMutationBody = IntegrationCreate
    export type CreateIntegrationEndpointApiV1IntegrationsIntegrationTypePostMutationError = HTTPValidationError

    /**
 * @summary Create Integration Endpoint
 */
export const useCreateIntegrationEndpointApiV1IntegrationsIntegrationTypePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIntegrationEndpointApiV1IntegrationsIntegrationTypePost>>, TError,{integrationType: IntegrationType;data: IntegrationCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof createIntegrationEndpointApiV1IntegrationsIntegrationTypePost>>,
        TError,
        {integrationType: IntegrationType;data: IntegrationCreate},
        TContext
      > => {

      const mutationOptions = getCreateIntegrationEndpointApiV1IntegrationsIntegrationTypePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Integration Endpoint
 */
export const getIntegrationEndpointApiV1IntegrationsIntegrationIdGet = (
    integrationId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<IntegrationRead>(
      {url: `/api/v1/integrations/${encodeURIComponent(String(integrationId))}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetQueryKey = (integrationId: string,) => {
    return [`/api/v1/integrations/${integrationId}`] as const;
    }

    
export const getGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(integrationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetQueryKey(integrationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>> = ({ signal }) => getIntegrationEndpointApiV1IntegrationsIntegrationIdGet(integrationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(integrationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIntegrationEndpointApiV1IntegrationsIntegrationIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>>
export type GetIntegrationEndpointApiV1IntegrationsIntegrationIdGetQueryError = HTTPValidationError


export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGet<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>,
          TError,
          Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGet<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>,
          TError,
          Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGet<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Integration Endpoint
 */

export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGet<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetQueryOptions(integrationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(integrationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetQueryKey(integrationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>> = ({ signal }) => getIntegrationEndpointApiV1IntegrationsIntegrationIdGet(integrationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>>
export type GetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspenseQueryError = HTTPValidationError


export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Integration Endpoint
 */

export function useGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError = HTTPValidationError>(
 integrationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationEndpointApiV1IntegrationsIntegrationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetIntegrationEndpointApiV1IntegrationsIntegrationIdGetSuspenseQueryOptions(integrationId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Integration Endpoint
 */
export const updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut = (
    integrationId: string,
    integrationUpdate: IntegrationUpdate,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<IntegrationRead>(
      {url: `/api/v1/integrations/${encodeURIComponent(String(integrationId))}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: integrationUpdate
    },
      options);
    }
  


export const getUpdateIntegrationEndpointApiV1IntegrationsIntegrationIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut>>, TError,{integrationId: string;data: IntegrationUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut>>, TError,{integrationId: string;data: IntegrationUpdate}, TContext> => {
    
const mutationKey = ['updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut>>, {integrationId: string;data: IntegrationUpdate}> = (props) => {
          const {integrationId,data} = props ?? {};

          return  updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut(integrationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateIntegrationEndpointApiV1IntegrationsIntegrationIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut>>>
    export type UpdateIntegrationEndpointApiV1IntegrationsIntegrationIdPutMutationBody = IntegrationUpdate
    export type UpdateIntegrationEndpointApiV1IntegrationsIntegrationIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Integration Endpoint
 */
export const useUpdateIntegrationEndpointApiV1IntegrationsIntegrationIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut>>, TError,{integrationId: string;data: IntegrationUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateIntegrationEndpointApiV1IntegrationsIntegrationIdPut>>,
        TError,
        {integrationId: string;data: IntegrationUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateIntegrationEndpointApiV1IntegrationsIntegrationIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Integration By Type Endpoint
 */
export const getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet = (
    integrationType: IntegrationType,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<IntegrationRead>(
      {url: `/api/v1/integrations/${encodeURIComponent(String(integrationType))}/me`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetQueryKey = (integrationType: IntegrationType,) => {
    return [`/api/v1/integrations/${integrationType}/me`] as const;
    }

    
export const getGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(integrationType: IntegrationType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetQueryKey(integrationType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>> = ({ signal }) => getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet(integrationType, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(integrationType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>>
export type GetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetQueryError = HTTPValidationError


export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>,
          TError,
          Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>,
          TError,
          Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Integration By Type Endpoint
 */

export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetQueryOptions(integrationType,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(integrationType: IntegrationType, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetQueryKey(integrationType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>> = ({ signal }) => getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet(integrationType, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>>
export type GetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspenseQueryError = HTTPValidationError


export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Integration By Type Endpoint
 */

export function useGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspense<TData = Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError = HTTPValidationError>(
 integrationType: IntegrationType, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetIntegrationByTypeEndpointApiV1IntegrationsIntegrationTypeMeGetSuspenseQueryOptions(integrationType,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



