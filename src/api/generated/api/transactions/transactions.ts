/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Current-Payment
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  GetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet200,
  GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet200,
  GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams,
  GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet200,
  GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams,
  GetTransactionsEndpointApiV1TransactionsGetParams,
  HTTPValidationError,
  TransactionCreate,
  TransactionRead,
  TransactionUpdate
} from '../../model';

import { customFetch } from '../../../mutator/custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create Transaction Endpoint
 */
export const createTransactionEndpointApiV1TransactionsPost = (
    transactionCreate: TransactionCreate,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/v1/transactions/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: transactionCreate, signal
    },
      options);
    }
  


export const getCreateTransactionEndpointApiV1TransactionsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransactionEndpointApiV1TransactionsPost>>, TError,{data: TransactionCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createTransactionEndpointApiV1TransactionsPost>>, TError,{data: TransactionCreate}, TContext> => {
    
const mutationKey = ['createTransactionEndpointApiV1TransactionsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTransactionEndpointApiV1TransactionsPost>>, {data: TransactionCreate}> = (props) => {
          const {data} = props ?? {};

          return  createTransactionEndpointApiV1TransactionsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTransactionEndpointApiV1TransactionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createTransactionEndpointApiV1TransactionsPost>>>
    export type CreateTransactionEndpointApiV1TransactionsPostMutationBody = TransactionCreate
    export type CreateTransactionEndpointApiV1TransactionsPostMutationError = HTTPValidationError

    /**
 * @summary Create Transaction Endpoint
 */
export const useCreateTransactionEndpointApiV1TransactionsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransactionEndpointApiV1TransactionsPost>>, TError,{data: TransactionCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof createTransactionEndpointApiV1TransactionsPost>>,
        TError,
        {data: TransactionCreate},
        TContext
      > => {

      const mutationOptions = getCreateTransactionEndpointApiV1TransactionsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Transactions Endpoint
 */
export const getTransactionsEndpointApiV1TransactionsGet = (
    params: GetTransactionsEndpointApiV1TransactionsGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<TransactionRead[]>(
      {url: `/api/v1/transactions/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTransactionsEndpointApiV1TransactionsGetQueryKey = (params: GetTransactionsEndpointApiV1TransactionsGetParams,) => {
    return [`/api/v1/transactions/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTransactionsEndpointApiV1TransactionsGetQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionsEndpointApiV1TransactionsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>> = ({ signal }) => getTransactionsEndpointApiV1TransactionsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionsEndpointApiV1TransactionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>>
export type GetTransactionsEndpointApiV1TransactionsGetQueryError = HTTPValidationError


export function useGetTransactionsEndpointApiV1TransactionsGet<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionsEndpointApiV1TransactionsGet<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionsEndpointApiV1TransactionsGet<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transactions Endpoint
 */

export function useGetTransactionsEndpointApiV1TransactionsGet<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionsEndpointApiV1TransactionsGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTransactionsEndpointApiV1TransactionsGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionsEndpointApiV1TransactionsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>> = ({ signal }) => getTransactionsEndpointApiV1TransactionsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionsEndpointApiV1TransactionsGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>>
export type GetTransactionsEndpointApiV1TransactionsGetSuspenseQueryError = HTTPValidationError


export function useGetTransactionsEndpointApiV1TransactionsGetSuspense<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionsEndpointApiV1TransactionsGetSuspense<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionsEndpointApiV1TransactionsGetSuspense<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transactions Endpoint
 */

export function useGetTransactionsEndpointApiV1TransactionsGetSuspense<TData = Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError = HTTPValidationError>(
 params: GetTransactionsEndpointApiV1TransactionsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionsEndpointApiV1TransactionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionsEndpointApiV1TransactionsGetSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Issue a transaction for a payment term
 * @summary Issue Transaction Endpoint
 */
export const issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost = (
    transactionId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<TransactionRead>(
      {url: `/api/v1/transactions/${encodeURIComponent(String(transactionId))}/issue`, method: 'POST', signal
    },
      options);
    }
  


export const getIssueTransactionEndpointApiV1TransactionsTransactionIdIssuePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost>>, TError,{transactionId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost>>, TError,{transactionId: string}, TContext> => {
    
const mutationKey = ['issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost>>, {transactionId: string}> = (props) => {
          const {transactionId} = props ?? {};

          return  issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost(transactionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IssueTransactionEndpointApiV1TransactionsTransactionIdIssuePostMutationResult = NonNullable<Awaited<ReturnType<typeof issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost>>>
    
    export type IssueTransactionEndpointApiV1TransactionsTransactionIdIssuePostMutationError = HTTPValidationError

    /**
 * @summary Issue Transaction Endpoint
 */
export const useIssueTransactionEndpointApiV1TransactionsTransactionIdIssuePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost>>, TError,{transactionId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof issueTransactionEndpointApiV1TransactionsTransactionIdIssuePost>>,
        TError,
        {transactionId: string},
        TContext
      > => {

      const mutationOptions = getIssueTransactionEndpointApiV1TransactionsTransactionIdIssuePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Transaction By Id Endpoint
 */
export const getTransactionByIdEndpointApiV1TransactionsTransactionIdGet = (
    transactionId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<TransactionRead>(
      {url: `/api/v1/transactions/${encodeURIComponent(String(transactionId))}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetQueryKey = (transactionId: string,) => {
    return [`/api/v1/transactions/${transactionId}`] as const;
    }

    
export const getGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(transactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetQueryKey(transactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>> = ({ signal }) => getTransactionByIdEndpointApiV1TransactionsTransactionIdGet(transactionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(transactionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionByIdEndpointApiV1TransactionsTransactionIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>>
export type GetTransactionByIdEndpointApiV1TransactionsTransactionIdGetQueryError = HTTPValidationError


export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGet<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGet<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGet<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transaction By Id Endpoint
 */

export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGet<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetQueryOptions(transactionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(transactionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetQueryKey(transactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>> = ({ signal }) => getTransactionByIdEndpointApiV1TransactionsTransactionIdGet(transactionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>>
export type GetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspenseQueryError = HTTPValidationError


export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspense<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspense<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspense<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transaction By Id Endpoint
 */

export function useGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspense<TData = Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError = HTTPValidationError>(
 transactionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionByIdEndpointApiV1TransactionsTransactionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionByIdEndpointApiV1TransactionsTransactionIdGetSuspenseQueryOptions(transactionId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Transaction Endpoint
 */
export const updateTransactionEndpointApiV1TransactionsTransactionIdPut = (
    transactionId: string,
    transactionUpdate: TransactionUpdate,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<TransactionRead>(
      {url: `/api/v1/transactions/${encodeURIComponent(String(transactionId))}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transactionUpdate
    },
      options);
    }
  


export const getUpdateTransactionEndpointApiV1TransactionsTransactionIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTransactionEndpointApiV1TransactionsTransactionIdPut>>, TError,{transactionId: string;data: TransactionUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTransactionEndpointApiV1TransactionsTransactionIdPut>>, TError,{transactionId: string;data: TransactionUpdate}, TContext> => {
    
const mutationKey = ['updateTransactionEndpointApiV1TransactionsTransactionIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTransactionEndpointApiV1TransactionsTransactionIdPut>>, {transactionId: string;data: TransactionUpdate}> = (props) => {
          const {transactionId,data} = props ?? {};

          return  updateTransactionEndpointApiV1TransactionsTransactionIdPut(transactionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTransactionEndpointApiV1TransactionsTransactionIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateTransactionEndpointApiV1TransactionsTransactionIdPut>>>
    export type UpdateTransactionEndpointApiV1TransactionsTransactionIdPutMutationBody = TransactionUpdate
    export type UpdateTransactionEndpointApiV1TransactionsTransactionIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Transaction Endpoint
 */
export const useUpdateTransactionEndpointApiV1TransactionsTransactionIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTransactionEndpointApiV1TransactionsTransactionIdPut>>, TError,{transactionId: string;data: TransactionUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateTransactionEndpointApiV1TransactionsTransactionIdPut>>,
        TError,
        {transactionId: string;data: TransactionUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateTransactionEndpointApiV1TransactionsTransactionIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get aggregated transaction data by specified dimensions from vendor's perspective
 * @summary Get Transaction Aggregated Data Vendor Endpoint
 */
export const getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet = (
    params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet200>(
      {url: `/api/v1/transactions/aggregated/vendor`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetQueryKey = (params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams,) => {
    return [`/api/v1/transactions/aggregated/vendor`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>> = ({ signal }) => getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>>
export type GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetQueryError = HTTPValidationError


export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transaction Aggregated Data Vendor Endpoint
 */

export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>> = ({ signal }) => getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>>
export type GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspenseQueryError = HTTPValidationError


export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transaction Aggregated Data Vendor Endpoint
 */

export function useGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionAggregatedDataVendorEndpointApiV1TransactionsAggregatedVendorGetSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get aggregated transaction data by specified dimensions from client's perspective
 * @summary Get Transaction Aggregated Data Client Endpoint
 */
export const getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet = (
    params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet200>(
      {url: `/api/v1/transactions/aggregated/client`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetQueryKey = (params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams,) => {
    return [`/api/v1/transactions/aggregated/client`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>> = ({ signal }) => getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>>
export type GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetQueryError = HTTPValidationError


export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transaction Aggregated Data Client Endpoint
 */

export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>> = ({ signal }) => getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>>
export type GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspenseQueryError = HTTPValidationError


export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transaction Aggregated Data Client Endpoint
 */

export function useGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspense<TData = Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError = HTTPValidationError>(
 params: GetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionAggregatedDataClientEndpointApiV1TransactionsAggregatedClientGetSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get monthly MRR (Monthly Recurring Revenue) for the vendor
 * @summary Get Monthly Mrr Endpoint
 */
export const getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<GetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet200>(
      {url: `/api/v1/transactions/aggregated/monthly-mrr`, method: 'GET', signal
    },
      options);
    }
  

export const getGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetQueryKey = () => {
    return [`/api/v1/transactions/aggregated/monthly-mrr`] as const;
    }

    
export const getGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetQueryOptions = <TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>> = ({ signal }) => getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>>
export type GetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetQueryError = unknown


export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>,
          TError,
          Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>,
          TError,
          Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Monthly Mrr Endpoint
 */

export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>> = ({ signal }) => getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>>
export type GetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspenseQueryError = unknown


export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspense<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspense<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspense<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Monthly Mrr Endpoint
 */

export function useGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspense<TData = Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMonthlyMrrEndpointApiV1TransactionsAggregatedMonthlyMrrGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



