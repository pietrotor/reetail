/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Current-Payment
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  BodyLogInEndpointApiV1UsersLoginPost,
  CreateUserEndpointApiV1UsersPostParams,
  HTTPValidationError,
  Token,
  UserCreate,
  UserRead,
  UserUpdate,
  VerifyEmailEndpointApiV1UsersVerifyPostParams
} from '../../model';

import { customFetch } from '../../../mutator/custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Create a new user.
 * @summary Create User Endpoint
 */
export const createUserEndpointApiV1UsersPost = (
    userCreate: UserCreate,
    params: CreateUserEndpointApiV1UsersPostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<UserRead>(
      {url: `/api/v1/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate,
        params, signal
    },
      options);
    }
  


export const getCreateUserEndpointApiV1UsersPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserEndpointApiV1UsersPost>>, TError,{data: UserCreate;params: CreateUserEndpointApiV1UsersPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createUserEndpointApiV1UsersPost>>, TError,{data: UserCreate;params: CreateUserEndpointApiV1UsersPostParams}, TContext> => {
    
const mutationKey = ['createUserEndpointApiV1UsersPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserEndpointApiV1UsersPost>>, {data: UserCreate;params: CreateUserEndpointApiV1UsersPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  createUserEndpointApiV1UsersPost(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserEndpointApiV1UsersPostMutationResult = NonNullable<Awaited<ReturnType<typeof createUserEndpointApiV1UsersPost>>>
    export type CreateUserEndpointApiV1UsersPostMutationBody = UserCreate
    export type CreateUserEndpointApiV1UsersPostMutationError = HTTPValidationError

    /**
 * @summary Create User Endpoint
 */
export const useCreateUserEndpointApiV1UsersPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserEndpointApiV1UsersPost>>, TError,{data: UserCreate;params: CreateUserEndpointApiV1UsersPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof createUserEndpointApiV1UsersPost>>,
        TError,
        {data: UserCreate;params: CreateUserEndpointApiV1UsersPostParams},
        TContext
      > => {

      const mutationOptions = getCreateUserEndpointApiV1UsersPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Login With Google
 */
export const loginWithGoogleApiV1UsersLoginGoogleGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/v1/users/login/google`, method: 'GET', signal
    },
      options);
    }
  

export const getLoginWithGoogleApiV1UsersLoginGoogleGetQueryKey = () => {
    return [`/api/v1/users/login/google`] as const;
    }

    
export const getLoginWithGoogleApiV1UsersLoginGoogleGetQueryOptions = <TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLoginWithGoogleApiV1UsersLoginGoogleGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>> = ({ signal }) => loginWithGoogleApiV1UsersLoginGoogleGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LoginWithGoogleApiV1UsersLoginGoogleGetQueryResult = NonNullable<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>>
export type LoginWithGoogleApiV1UsersLoginGoogleGetQueryError = unknown


export function useLoginWithGoogleApiV1UsersLoginGoogleGet<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>,
          TError,
          Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithGoogleApiV1UsersLoginGoogleGet<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>,
          TError,
          Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithGoogleApiV1UsersLoginGoogleGet<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Login With Google
 */

export function useLoginWithGoogleApiV1UsersLoginGoogleGet<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLoginWithGoogleApiV1UsersLoginGoogleGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getLoginWithGoogleApiV1UsersLoginGoogleGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLoginWithGoogleApiV1UsersLoginGoogleGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>> = ({ signal }) => loginWithGoogleApiV1UsersLoginGoogleGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LoginWithGoogleApiV1UsersLoginGoogleGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>>
export type LoginWithGoogleApiV1UsersLoginGoogleGetSuspenseQueryError = unknown


export function useLoginWithGoogleApiV1UsersLoginGoogleGetSuspense<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithGoogleApiV1UsersLoginGoogleGetSuspense<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithGoogleApiV1UsersLoginGoogleGetSuspense<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Login With Google
 */

export function useLoginWithGoogleApiV1UsersLoginGoogleGetSuspense<TData = Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithGoogleApiV1UsersLoginGoogleGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLoginWithGoogleApiV1UsersLoginGoogleGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Auth Google Callback
 */
export const authGoogleCallbackApiV1UsersAuthGoogleCallbackGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/v1/users/auth/google/callback`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetQueryKey = () => {
    return [`/api/v1/users/auth/google/callback`] as const;
    }

    
export const getAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetQueryOptions = <TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>> = ({ signal }) => authGoogleCallbackApiV1UsersAuthGoogleCallbackGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetQueryResult = NonNullable<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>>
export type AuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetQueryError = unknown


export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>,
          TError,
          Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>,
          TError,
          Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Auth Google Callback
 */

export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGet<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>> = ({ signal }) => authGoogleCallbackApiV1UsersAuthGoogleCallbackGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>>
export type AuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspenseQueryError = unknown


export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspense<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspense<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspense<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Auth Google Callback
 */

export function useAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspense<TData = Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authGoogleCallbackApiV1UsersAuthGoogleCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthGoogleCallbackApiV1UsersAuthGoogleCallbackGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Login With Microsoft
 */
export const loginWithMicrosoftApiV1UsersLoginMicrosoftGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/v1/users/login/microsoft`, method: 'GET', signal
    },
      options);
    }
  

export const getLoginWithMicrosoftApiV1UsersLoginMicrosoftGetQueryKey = () => {
    return [`/api/v1/users/login/microsoft`] as const;
    }

    
export const getLoginWithMicrosoftApiV1UsersLoginMicrosoftGetQueryOptions = <TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLoginWithMicrosoftApiV1UsersLoginMicrosoftGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>> = ({ signal }) => loginWithMicrosoftApiV1UsersLoginMicrosoftGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LoginWithMicrosoftApiV1UsersLoginMicrosoftGetQueryResult = NonNullable<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>>
export type LoginWithMicrosoftApiV1UsersLoginMicrosoftGetQueryError = unknown


export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGet<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>,
          TError,
          Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGet<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>,
          TError,
          Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGet<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Login With Microsoft
 */

export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGet<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLoginWithMicrosoftApiV1UsersLoginMicrosoftGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getLoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLoginWithMicrosoftApiV1UsersLoginMicrosoftGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>> = ({ signal }) => loginWithMicrosoftApiV1UsersLoginMicrosoftGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>>
export type LoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspenseQueryError = unknown


export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspense<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspense<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspense<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Login With Microsoft
 */

export function useLoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspense<TData = Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof loginWithMicrosoftApiV1UsersLoginMicrosoftGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLoginWithMicrosoftApiV1UsersLoginMicrosoftGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Auth Microsoft Callback
 */
export const authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<unknown>(
      {url: `/api/v1/users/auth/microsoft/callback`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetQueryKey = () => {
    return [`/api/v1/users/auth/microsoft/callback`] as const;
    }

    
export const getAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetQueryOptions = <TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>> = ({ signal }) => authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetQueryResult = NonNullable<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>>
export type AuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetQueryError = unknown


export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>,
          TError,
          Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>,
          TError,
          Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Auth Microsoft Callback
 */

export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>> = ({ signal }) => authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>>
export type AuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspenseQueryError = unknown


export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspense<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspense<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspense<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Auth Microsoft Callback
 */

export function useAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspense<TData = Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof authMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthMicrosoftCallbackApiV1UsersAuthMicrosoftCallbackGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Me Endpoint
 */
export const getMeEndpointApiV1UsersMeGet = (
    
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<UserRead>(
      {url: `/api/v1/users/me`, method: 'GET', signal
    },
      options);
    }
  

export const getGetMeEndpointApiV1UsersMeGetQueryKey = () => {
    return [`/api/v1/users/me`] as const;
    }

    
export const getGetMeEndpointApiV1UsersMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeEndpointApiV1UsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>> = ({ signal }) => getMeEndpointApiV1UsersMeGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeEndpointApiV1UsersMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>>
export type GetMeEndpointApiV1UsersMeGetQueryError = unknown


export function useGetMeEndpointApiV1UsersMeGet<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeEndpointApiV1UsersMeGet<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeEndpointApiV1UsersMeGet<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Me Endpoint
 */

export function useGetMeEndpointApiV1UsersMeGet<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeEndpointApiV1UsersMeGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMeEndpointApiV1UsersMeGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeEndpointApiV1UsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>> = ({ signal }) => getMeEndpointApiV1UsersMeGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeEndpointApiV1UsersMeGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>>
export type GetMeEndpointApiV1UsersMeGetSuspenseQueryError = unknown


export function useGetMeEndpointApiV1UsersMeGetSuspense<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeEndpointApiV1UsersMeGetSuspense<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeEndpointApiV1UsersMeGetSuspense<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Me Endpoint
 */

export function useGetMeEndpointApiV1UsersMeGetSuspense<TData = Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMeEndpointApiV1UsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeEndpointApiV1UsersMeGetSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get User Endpoint
 */
export const getUserEndpointApiV1UsersUserIdGet = (
    userId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<UserRead>(
      {url: `/api/v1/users/${encodeURIComponent(String(userId))}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserEndpointApiV1UsersUserIdGetQueryKey = (userId: string,) => {
    return [`/api/v1/users/${userId}`] as const;
    }

    
export const getGetUserEndpointApiV1UsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserEndpointApiV1UsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>> = ({ signal }) => getUserEndpointApiV1UsersUserIdGet(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserEndpointApiV1UsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>>
export type GetUserEndpointApiV1UsersUserIdGetQueryError = HTTPValidationError


export function useGetUserEndpointApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserEndpointApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserEndpointApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Endpoint
 */

export function useGetUserEndpointApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserEndpointApiV1UsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserEndpointApiV1UsersUserIdGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserEndpointApiV1UsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>> = ({ signal }) => getUserEndpointApiV1UsersUserIdGet(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserEndpointApiV1UsersUserIdGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>>
export type GetUserEndpointApiV1UsersUserIdGetSuspenseQueryError = HTTPValidationError


export function useGetUserEndpointApiV1UsersUserIdGetSuspense<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserEndpointApiV1UsersUserIdGetSuspense<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserEndpointApiV1UsersUserIdGetSuspense<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Endpoint
 */

export function useGetUserEndpointApiV1UsersUserIdGetSuspense<TData = Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserEndpointApiV1UsersUserIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserEndpointApiV1UsersUserIdGetSuspenseQueryOptions(userId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update User Endpoint
 */
export const updateUserEndpointApiV1UsersUserIdPut = (
    userId: string,
    userUpdate: UserUpdate,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<UserRead>(
      {url: `/api/v1/users/${encodeURIComponent(String(userId))}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      options);
    }
  


export const getUpdateUserEndpointApiV1UsersUserIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserEndpointApiV1UsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserEndpointApiV1UsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext> => {
    
const mutationKey = ['updateUserEndpointApiV1UsersUserIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserEndpointApiV1UsersUserIdPut>>, {userId: string;data: UserUpdate}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserEndpointApiV1UsersUserIdPut(userId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserEndpointApiV1UsersUserIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserEndpointApiV1UsersUserIdPut>>>
    export type UpdateUserEndpointApiV1UsersUserIdPutMutationBody = UserUpdate
    export type UpdateUserEndpointApiV1UsersUserIdPutMutationError = HTTPValidationError

    /**
 * @summary Update User Endpoint
 */
export const useUpdateUserEndpointApiV1UsersUserIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserEndpointApiV1UsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUserEndpointApiV1UsersUserIdPut>>,
        TError,
        {userId: string;data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateUserEndpointApiV1UsersUserIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Log in a user.
 * @summary Log In Endpoint
 */
export const logInEndpointApiV1UsersLoginPost = (
    bodyLogInEndpointApiV1UsersLoginPost: BodyLogInEndpointApiV1UsersLoginPost,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyLogInEndpointApiV1UsersLoginPost.grant_type !== undefined && bodyLogInEndpointApiV1UsersLoginPost.grant_type !== null) {
 formUrlEncoded.append('grant_type', bodyLogInEndpointApiV1UsersLoginPost.grant_type)
 }
formUrlEncoded.append('username', bodyLogInEndpointApiV1UsersLoginPost.username)
formUrlEncoded.append('password', bodyLogInEndpointApiV1UsersLoginPost.password)
if(bodyLogInEndpointApiV1UsersLoginPost.scope !== undefined) {
 formUrlEncoded.append('scope', bodyLogInEndpointApiV1UsersLoginPost.scope)
 }
if(bodyLogInEndpointApiV1UsersLoginPost.client_id !== undefined && bodyLogInEndpointApiV1UsersLoginPost.client_id !== null) {
 formUrlEncoded.append('client_id', bodyLogInEndpointApiV1UsersLoginPost.client_id)
 }
if(bodyLogInEndpointApiV1UsersLoginPost.client_secret !== undefined && bodyLogInEndpointApiV1UsersLoginPost.client_secret !== null) {
 formUrlEncoded.append('client_secret', bodyLogInEndpointApiV1UsersLoginPost.client_secret)
 }

      return customFetch<Token>(
      {url: `/api/v1/users/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      options);
    }
  


export const getLogInEndpointApiV1UsersLoginPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logInEndpointApiV1UsersLoginPost>>, TError,{data: BodyLogInEndpointApiV1UsersLoginPost}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof logInEndpointApiV1UsersLoginPost>>, TError,{data: BodyLogInEndpointApiV1UsersLoginPost}, TContext> => {
    
const mutationKey = ['logInEndpointApiV1UsersLoginPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logInEndpointApiV1UsersLoginPost>>, {data: BodyLogInEndpointApiV1UsersLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  logInEndpointApiV1UsersLoginPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogInEndpointApiV1UsersLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof logInEndpointApiV1UsersLoginPost>>>
    export type LogInEndpointApiV1UsersLoginPostMutationBody = BodyLogInEndpointApiV1UsersLoginPost
    export type LogInEndpointApiV1UsersLoginPostMutationError = HTTPValidationError

    /**
 * @summary Log In Endpoint
 */
export const useLogInEndpointApiV1UsersLoginPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logInEndpointApiV1UsersLoginPost>>, TError,{data: BodyLogInEndpointApiV1UsersLoginPost}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof logInEndpointApiV1UsersLoginPost>>,
        TError,
        {data: BodyLogInEndpointApiV1UsersLoginPost},
        TContext
      > => {

      const mutationOptions = getLogInEndpointApiV1UsersLoginPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Verify Email Endpoint
 */
export const verifyEmailEndpointApiV1UsersVerifyPost = (
    params: VerifyEmailEndpointApiV1UsersVerifyPostParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<void>(
      {url: `/api/v1/users/verify`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getVerifyEmailEndpointApiV1UsersVerifyPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEmailEndpointApiV1UsersVerifyPost>>, TError,{params: VerifyEmailEndpointApiV1UsersVerifyPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyEmailEndpointApiV1UsersVerifyPost>>, TError,{params: VerifyEmailEndpointApiV1UsersVerifyPostParams}, TContext> => {
    
const mutationKey = ['verifyEmailEndpointApiV1UsersVerifyPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyEmailEndpointApiV1UsersVerifyPost>>, {params: VerifyEmailEndpointApiV1UsersVerifyPostParams}> = (props) => {
          const {params} = props ?? {};

          return  verifyEmailEndpointApiV1UsersVerifyPost(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyEmailEndpointApiV1UsersVerifyPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyEmailEndpointApiV1UsersVerifyPost>>>
    
    export type VerifyEmailEndpointApiV1UsersVerifyPostMutationError = HTTPValidationError

    /**
 * @summary Verify Email Endpoint
 */
export const useVerifyEmailEndpointApiV1UsersVerifyPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEmailEndpointApiV1UsersVerifyPost>>, TError,{params: VerifyEmailEndpointApiV1UsersVerifyPostParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyEmailEndpointApiV1UsersVerifyPost>>,
        TError,
        {params: VerifyEmailEndpointApiV1UsersVerifyPostParams},
        TContext
      > => {

      const mutationOptions = getVerifyEmailEndpointApiV1UsersVerifyPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    