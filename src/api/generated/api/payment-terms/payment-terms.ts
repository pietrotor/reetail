/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * Current-Payment
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams,
  HTTPValidationError,
  PaymentTermClientUpdate,
  PaymentTermCreate,
  PaymentTermRead,
  PaymentTermUpdateVendor
} from '../../model';

import { customFetch } from '../../../mutator/custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create Payment Term Endpoint
 */
export const createPaymentTermEndpointApiV1PaymentTermsPost = (
    paymentTermCreate: PaymentTermCreate,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<PaymentTermRead>(
      {url: `/api/v1/payment-terms/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentTermCreate, signal
    },
      options);
    }
  


export const getCreatePaymentTermEndpointApiV1PaymentTermsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPaymentTermEndpointApiV1PaymentTermsPost>>, TError,{data: PaymentTermCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createPaymentTermEndpointApiV1PaymentTermsPost>>, TError,{data: PaymentTermCreate}, TContext> => {
    
const mutationKey = ['createPaymentTermEndpointApiV1PaymentTermsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPaymentTermEndpointApiV1PaymentTermsPost>>, {data: PaymentTermCreate}> = (props) => {
          const {data} = props ?? {};

          return  createPaymentTermEndpointApiV1PaymentTermsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePaymentTermEndpointApiV1PaymentTermsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createPaymentTermEndpointApiV1PaymentTermsPost>>>
    export type CreatePaymentTermEndpointApiV1PaymentTermsPostMutationBody = PaymentTermCreate
    export type CreatePaymentTermEndpointApiV1PaymentTermsPostMutationError = HTTPValidationError

    /**
 * @summary Create Payment Term Endpoint
 */
export const useCreatePaymentTermEndpointApiV1PaymentTermsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPaymentTermEndpointApiV1PaymentTermsPost>>, TError,{data: PaymentTermCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof createPaymentTermEndpointApiV1PaymentTermsPost>>,
        TError,
        {data: PaymentTermCreate},
        TContext
      > => {

      const mutationOptions = getCreatePaymentTermEndpointApiV1PaymentTermsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Payment Terms By Vendor Endpoint
 */
export const getPaymentTermsByVendorEndpointApiV1PaymentTermsGet = (
    params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<PaymentTermRead[]>(
      {url: `/api/v1/payment-terms/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetQueryKey = (params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams,) => {
    return [`/api/v1/payment-terms/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>> = ({ signal }) => getPaymentTermsByVendorEndpointApiV1PaymentTermsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>>
export type GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetQueryError = HTTPValidationError


export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGet<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params: undefined |  GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGet<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGet<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Payment Terms By Vendor Endpoint
 */

export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGet<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>> = ({ signal }) => getPaymentTermsByVendorEndpointApiV1PaymentTermsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>>
export type GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspenseQueryError = HTTPValidationError


export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params: undefined |  GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Payment Terms By Vendor Endpoint
 */

export function useGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError = HTTPValidationError>(
 params?: GetPaymentTermsByVendorEndpointApiV1PaymentTermsGetParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermsByVendorEndpointApiV1PaymentTermsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPaymentTermsByVendorEndpointApiV1PaymentTermsGetSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Payment Term Endpoint
 */
export const getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet = (
    paymentTermId: string,
 options?: SecondParameter<typeof customFetch>,signal?: AbortSignal
) => {
      
      
      return customFetch<PaymentTermRead>(
      {url: `/api/v1/payment-terms/${encodeURIComponent(String(paymentTermId))}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetQueryKey = (paymentTermId: string,) => {
    return [`/api/v1/payment-terms/${paymentTermId}`] as const;
    }

    
export const getGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(paymentTermId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetQueryKey(paymentTermId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>> = ({ signal }) => getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet(paymentTermId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(paymentTermId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>>
export type GetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetQueryError = HTTPValidationError


export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Payment Term Endpoint
 */

export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetQueryOptions(paymentTermId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(paymentTermId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetQueryKey(paymentTermId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>> = ({ signal }) => getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet(paymentTermId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>>
export type GetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspenseQueryError = HTTPValidationError


export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Payment Term Endpoint
 */

export function useGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspense<TData = Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError = HTTPValidationError>(
 paymentTermId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPaymentTermEndpointApiV1PaymentTermsPaymentTermIdGetSuspenseQueryOptions(paymentTermId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Payment Term Vendor Endpoint
 */
export const updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut = (
    paymentTermId: string,
    paymentTermUpdateVendor: PaymentTermUpdateVendor,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PaymentTermRead>(
      {url: `/api/v1/payment-terms/${encodeURIComponent(String(paymentTermId))}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: paymentTermUpdateVendor
    },
      options);
    }
  


export const getUpdatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut>>, TError,{paymentTermId: string;data: PaymentTermUpdateVendor}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut>>, TError,{paymentTermId: string;data: PaymentTermUpdateVendor}, TContext> => {
    
const mutationKey = ['updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut>>, {paymentTermId: string;data: PaymentTermUpdateVendor}> = (props) => {
          const {paymentTermId,data} = props ?? {};

          return  updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut(paymentTermId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut>>>
    export type UpdatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPutMutationBody = PaymentTermUpdateVendor
    export type UpdatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Payment Term Vendor Endpoint
 */
export const useUpdatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut>>, TError,{paymentTermId: string;data: PaymentTermUpdateVendor}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPut>>,
        TError,
        {paymentTermId: string;data: PaymentTermUpdateVendor},
        TContext
      > => {

      const mutationOptions = getUpdatePaymentTermVendorEndpointApiV1PaymentTermsPaymentTermIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Update Payment Term Client Endpoint
 */
export const updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut = (
    paymentTermId: string,
    paymentTermClientUpdate: PaymentTermClientUpdate,
 options?: SecondParameter<typeof customFetch>,) => {
      
      
      return customFetch<PaymentTermRead>(
      {url: `/api/v1/payment-terms/${encodeURIComponent(String(paymentTermId))}/client`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: paymentTermClientUpdate
    },
      options);
    }
  


export const getUpdatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut>>, TError,{paymentTermId: string;data: PaymentTermClientUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut>>, TError,{paymentTermId: string;data: PaymentTermClientUpdate}, TContext> => {
    
const mutationKey = ['updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut>>, {paymentTermId: string;data: PaymentTermClientUpdate}> = (props) => {
          const {paymentTermId,data} = props ?? {};

          return  updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut(paymentTermId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPutMutationResult = NonNullable<Awaited<ReturnType<typeof updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut>>>
    export type UpdatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPutMutationBody = PaymentTermClientUpdate
    export type UpdatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPutMutationError = HTTPValidationError

    /**
 * @summary Update Payment Term Client Endpoint
 */
export const useUpdatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut>>, TError,{paymentTermId: string;data: PaymentTermClientUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPut>>,
        TError,
        {paymentTermId: string;data: PaymentTermClientUpdate},
        TContext
      > => {

      const mutationOptions = getUpdatePaymentTermClientEndpointApiV1PaymentTermsPaymentTermIdClientPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    